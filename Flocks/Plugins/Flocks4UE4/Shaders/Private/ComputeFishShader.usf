#include "/Engine/Private/Common.ush"

struct BoidData{
	int instanceId;
	float accelerationSpeed;
	float maxVelocity;
	float3 velocity;
	float3 position;
	float3 acceleration;
};

struct VolumeData{
	int instanceId;
	float3 position;
	float innerRadius;
	float outerRadius;
	float falloff;
	int volumeType;
};

float getDistance(float3 v1, float3 v2) {
	return sqrt((v2[0]-v1[0])*(v2[0]-v1[0]) + (v2[1]-v1[1])*(v2[1]-v1[1]) + (v2[2]-v1[2])*(v2[2]-v1[2]));
}

RWStructuredBuffer<BoidData> data;
RWStructuredBuffer<VolumeData> volumeData;

[numthreads(1, 128, 1)]
void VS_test(uint3 ThreadId : SV_DispatchThreadID)
{		
	int numBoids = FlocksConstant.NumBoids;
	int calculationsPerThread = FlocksConstant.CalculationsPerThread;

	float cohesionRadius = FlocksConstant.CohesionRadius;
	float alignmentRadius = FlocksConstant.AlignmentRadius;
	float separationRadius = FlocksConstant.SeparationRadius;
	float cohesion = FlocksConstant.Cohesion;
	float alignment = FlocksConstant.Alignment;
	float separation = FlocksConstant.Separation;
	
	for (int iteration = 0; iteration < calculationsPerThread; iteration++) {		
		int currentThreadId = calculationsPerThread * ThreadId.y + iteration;
		
		if (currentThreadId >= numBoids)
			return;
			
		int currentId = numBoids + currentThreadId;
		BoidData currentState = data[currentThreadId + numBoids];
		BoidData newState = data[currentThreadId];
	
		float3 steerCohesion = {0.0f, 0.0f, 0.0f};
		float3 steerSeparation = {0.0f, 0.0f, 0.0f};
		float3 steerAlignment = {0.0f, 0.0f, 0.0f};
	
		float steerCohesionCnt = 0.0f;
		float steerSeparationCnt = 0.0f;
		float steerAlignmentCnt = 0.0f;
	
		for (int i = numBoids; i < 2 * numBoids; i++) {
			if (i != currentId) {
				float d = getDistance(data[i].position, currentState.position);
				if (d < cohesionRadius) {
					steerCohesion += data[i].position;
					steerCohesionCnt++;
				}
				if (d < separationRadius) {
					steerSeparation += data[i].position - currentState.position;
					steerSeparationCnt++;
				}
				if (d < alignmentRadius) {
					steerAlignment += data[i].velocity;
					steerAlignmentCnt++;
				}
			}
		}

		float closestDist = 100000000;
		int closestRest = -1;

		for(int j = 0; j < FlocksVariable.NumVolumes; ++j)
		{
			float d = getDistance(volumeData[j].position, currentState.position);
			if(d < closestDist)
			{
				closestDist = d;
				closestRest = j;
			}
		}

		float3 steerRestriction = float3(0, 0, 0);
		float restriction = 0.0f;
		if(closestRest > -1 && closestDist > volumeData[closestRest].outerRadius)
		{
			restriction = 1.0f;
			steerRestriction = volumeData[closestRest].position - currentState.position;
			steerRestriction = normalize(steerRestriction);
		}

		if (steerCohesionCnt != 0) {
			steerCohesion = (steerCohesion / steerCohesionCnt - currentState.position);
			steerCohesion = normalize(steerCohesion);
		}

		if (steerSeparationCnt != 0) {
			steerSeparation = -1.f * (steerSeparation / steerSeparationCnt);
			steerSeparation = normalize(steerSeparation);
		}

		if (steerAlignmentCnt != 0) {
			steerAlignment /= steerAlignmentCnt;
			steerAlignment = normalize(steerAlignment);
		}
	
		newState.acceleration = (steerCohesion * cohesion + steerSeparation * separation + steerAlignment * alignment + steerRestriction * restriction) * currentState.accelerationSpeed;
	
		newState.velocity += newState.acceleration * FlocksVariable.DeltaSeconds;
		newState.velocity = clamp(newState.velocity, -currentState.maxVelocity, currentState.maxVelocity);

		newState.position += newState.velocity * FlocksVariable.DeltaSeconds;
	
		data[currentThreadId] = newState;
	}
}
