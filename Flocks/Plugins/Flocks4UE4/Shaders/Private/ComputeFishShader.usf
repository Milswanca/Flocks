#include "/Engine/Private/Common.ush"

struct BoidData{
	int instanceId;
	float3 velocity;
	float3 position;
	float3 acceleration;
};

float getDistance(float3 v1, float3 v2) {
	return sqrt((v2[0]-v1[0])*(v2[0]-v1[0]) + (v2[1]-v1[1])*(v2[1]-v1[1]) + (v2[2]-v1[2])*(v2[2]-v1[2]));
}

RWStructuredBuffer<BoidData> data;

[numthreads(1, 128, 1)]
void VS_test(uint3 ThreadId : SV_DispatchThreadID)
{		
	int numBoids = FlocksConstant.NumBoids;
	int calculationsPerThread = FlocksConstant.CalculationsPerThread;

	float cohesionRadius = FlocksConstant.CohesionRadius;
	float alignmentRadius = FlocksConstant.AlignmentRadius;
	float separationRadius = FlocksConstant.SeparationRadius;
	float cohesion = FlocksConstant.Cohesion;
	float alignment = FlocksConstant.Alignment;
	float separation = FlocksConstant.Separation;
	
	for (int iteration = 0; iteration < calculationsPerThread; iteration++) {		
		int currentThreadId = calculationsPerThread * ThreadId.y + iteration;
		
		if (currentThreadId >= numBoids)
			return;
			
		int currentId = numBoids + currentThreadId;
		BoidData currentState = data[currentThreadId + numBoids];
		BoidData newState = data[currentThreadId];
	
		float3 steerCohesion = {0.0f, 0.0f, 0.0f};
		float3 steerSeparation = {0.0f, 0.0f, 0.0f};
		float3 steerAlignment = {0.0f, 0.0f, 0.0f};
	
		float steerCohesionCnt = 0.0f;
		float steerSeparationCnt = 0.0f;
		float steerAlignmentCnt = 0.0f;
	
		for (int i = numBoids; i < 2 * numBoids; i++) {
			if (i != currentId) {
				float d = getDistance(data[i].position, currentState.position);
				if (d < cohesionRadius) {
					steerCohesion += data[i].position;
					steerCohesionCnt++;
				}
				if (d < separationRadius) {
					steerSeparation += data[i].position - currentState.position;
					steerSeparationCnt++;
				}
				if (d < alignmentRadius) {
					steerAlignment += data[i].velocity;
					steerAlignmentCnt++;
				}
			}
		}

		if (steerCohesionCnt != 0) {
			steerCohesion = (steerCohesion / steerCohesionCnt - currentState.position);
			steerCohesion = normalize(steerCohesion);
		}

		if (steerSeparationCnt != 0) {
			steerSeparation = -1.f * (steerSeparation / steerSeparationCnt);
			steerSeparation = normalize(steerSeparation);
		}

		if (steerAlignmentCnt != 0) {
			steerAlignment /= steerAlignmentCnt;
			steerAlignment = normalize(steerAlignment);
		}
	
		newState.acceleration = (steerCohesion * cohesion + steerSeparation * separation + steerAlignment * alignment) * FlocksConstant.Acceleration;
	
		newState.velocity += newState.acceleration * FlocksVariable.DeltaSeconds;
		newState.velocity = clamp(newState.velocity, -FlocksConstant.MaxVelocity, FlocksConstant.MaxVelocity);

		newState.position += newState.velocity * FlocksVariable.DeltaSeconds;
	
		data[currentThreadId] = newState;
	}
}
